# Отчёт 30.12.25

**Кратко:** добавлено циклическое чтение HTTP-запроса (чтение заголовков в цикле до `\r\n\r\n`) и функция `handle_connection` разбита на несколько мелких helper-функций.

---

## Зачем:

1. Исправить небезопасное однократное чтение заголовков запроса (когда `read()` мог вернуть не все заголовки).
2. Улучшить читаемость и поддержку кода - уменьшить размер функции `handle_connection` и вынести логические части в отдельные маленькие функции.

## Что сделано

* **Циклическое чтение заголовков**: реализована функция `read_request_headers(int fd, char *buf, size_t bufsize)` - она читает данные из сокета в цикл до тех пор, пока не встретит конец HTTP-заголовков `\r\n\r\n` или пока не заполнится буфер.

* **Разбиение на функции**: `handle_connection` теперь короткая и координирует работу, а детали вынесены в следующие helper-функции:

  * `ssize_t read_request_headers(int fd, char *buf, size_t bufsize)` - чтение заголовков в цикл;
  * `int extract_host_from_headers(const char *headers, char *host, size_t hostsize)` - извлечение значения `Host:` из заголовков;
  * `int resolve_and_connect(const char *host, int port)` - `gethostbyname` + `socket` + `connect`;
  * `ssize_t forward_request(int server_fd, const char *buf, size_t len)` - отправка уже прочитанных байтов запроса на удалённый сервер;
  * `void relay_response(int server_fd, int client_fd)` - пересылка ответа с сервера клиенту по кускам.

### Чтение заголовков в цикле

* `read()` на сокете не гарантирует, что вернётся весь HTTP-запрос (особенно если клиент посылает заголовки крупными или множественными пакетами).
* Если читать один раз и парсить сразу, можно получить неполные заголовки и не найти `Host:` или `\r\n\r\n`.

* Мы читаем в буфер `buf` в цикле, накапливая `total` байт.
* После каждого чтения ставим нулевой байт `buf[total] = '\0'` и проверяем `strstr(buf, "\r\n\r\n")`.
* Если найдено - выходим и возвращаем количество прочитанных байт.
* Также выходим, если буфер заполнился или `read()` вернул ошибку/EOF.

Ограничение:

* Буфер фиксированного размера (`BUFFER_SIZE`); если заголовки превышают этот размер, лишние данные отбрасываются - это поведение сохранено из исходного кода. В дальнейшем можно заменить на динамическое расширение буфера.